<?xml version="1.0"?>
<doc>
<assembly>
<name>
ComponentDiscovery
</name>
</assembly>
<members>
<member name="M:System.Threading.CallTreeTracker.#ctor(System.Action,System.Func{System.Boolean,System.Boolean})">
 <summary>
 </summary>
 <param name="onLifetimeEnded"></param>
 <param name="trackingFilter">
   is called at the start of a new child-thread and gives the chance to decide 
   if the new thread sould be tracked or not
   (the boolean param informs about the tracking of the parent thread)
 </param>
</member>
<member name="P:System.Threading.CallTreeTracker.ThreadNode.Tracked">
 <summary>
 if false, the node is disregarded when waiting for running threads
 </summary>
 <returns></returns>
</member>
<member name="M:ComponentDiscovery.HelperExtensions.GetTypesAccessible(System.Reflection.Assembly)">
 <summary>
   A really important secret is that the common method "GetTypes()" will fail
   if the assembly contains one or more types with broken references (to non existing assemblies).
   This method 'GetTypesAccessable()' will handle this problem and return at least those types,
   which could be loaded!
 </summary>
</member>
<member name="M:ComponentDiscovery.HelperExtensions.GetTypesAccessible(System.Reflection.Assembly,System.Action{System.Exception})">
 <summary>
   A really important secret is that the common method "GetTypes()" will fail
   if the assembly contains one or more types with broken references (to non existing assemblies).
   This method 'GetTypesAccessable()' will handle this problem and return at least those types,
   which could be loaded!
 </summary>
</member>
<member name="M:ComponentDiscovery.PriorityList`1.DumpPreferences">
 <summary>
 Generates a Report for Diagnostics and Troubleshooting
 </summary>
</member>
<member name="M:ComponentDiscovery.PriorityList`1.TryDeclarePreference(`0,`0)">
 <summary>
 retuns false, if the rule cant be applied because of cyclic references or
 when trying to priorize fallback-items before preferred items...
 throws an exception, if one of the given items is not present in the list
 </summary>
 <param name="higherPriorityItem">use null to address any unknown</param>
 <param name="lowerPriorityItem">use null to address any unknown</param>
 <returns></returns>
</member>
<member name="M:ComponentDiscovery.AssemblyIndexer.OnLazyInitializing">
 <summary>
 a Hook to do some self-initialzation logic (for example pulling some default clearances)
 exactly at the moment when the current instance gets its first subscriber
 </summary>
</member>
<member name="M:ComponentDiscovery.AssemblyIndexer.DumpFullState">
 <summary>
 Generates a Report for Diagnostics and Troubleshooting
 </summary>
</member>
<member name="M:ComponentDiscovery.AssemblyIndexer.Dispose(System.Boolean)">
 <summary>
   Dispose the current object instance
 </summary>
</member>
<member name="M:ComponentDiscovery.AssemblyIndexer.Dispose">
 <summary>
   Dispose the current object instance and suppress the finalizer
 </summary>
</member>
<member name="E:ComponentDiscovery.ClassificationBasedAssemblyIndexer.TaxonomicDimension.ClearancesAdded">
 <summary>
   Occurs when clearance expressions have actually been added to the clearance collection.
 </summary>
 <param name="addedClearanceExpressions"> An array of the effectively added labels. </param>
</member>
<member name="M:ComponentDiscovery.ClassificationBasedAssemblyIndexer.TaxonomicDimension.AddClearancesFromAssembly(System.String)">
 <summary>
   Adds the classification expressions of an assembly to the clearance collection.
   This will instantly make the assembly approvable.
 </summary>
 <returns>
   True, if at least one new expression has actually been added to the clearance collection.
 </returns>
</member>
<member name="M:ComponentDiscovery.ClassificationBasedAssemblyIndexer.TaxonomicDimension.AddClearances(System.String[])">
 <summary>
   Adds further expressions to the clearance collection. Duplicates will be ignored.
   Expanding the clearance collection will broaden the set of approvable assemblies.
   Note: if you plan to call this method multiple times (may be to setup multiple dimensions) then you
   should use the 'ClassifiactionBAsedAssemblyIndexer.ImportClearances' instead to prevent performance-issues!
 </summary>
 <returns>
   True, if at least one new expression has actually been added to the ClearanceLabels collection.
 </returns>
</member>
<member name="M:ComponentDiscovery.ClassificationBasedAssemblyIndexer.TaxonomicDimension.GetClassificationsWithRuntimeCaching(System.String)">
 <summary>
 </summary>
 <param name="assemblyFullFilename"></param>
 <returns>RETURNS NOTHING IN CASE OF A DETECTION ERROR!</returns>
</member>
<member name="P:ComponentDiscovery.ClassificationBasedAssemblyIndexer.TaxonomicDimensions">
 <summary>
 Dimensions to scope the set of available assemblies based on a taxonomy/wording to declare assembly classification expressions
 (independend form other dimensions). At Runtime, the clearances of EACH taxonomic dimension needs to match before an assembly becomes approved.
 </summary>
</member>
<member name="P:ComponentDiscovery.ClassificationBasedAssemblyIndexer.TaxonomicDimensions(System.String)">
 <summary>
 Dimensions to scope the set of available assemblies based on a taxonomy/wording to declare assembly classification expressions
 (independend form other dimensions). At Runtime, the clearances of EACH taxonomic dimension needs to match before an assembly becomes approved.
 </summary>
</member>
<member name="P:ComponentDiscovery.ClassificationBasedAssemblyIndexer.TaxonomicDimensionNames">
 <summary>
 Dimensions to scope the set of available assemblies based on a taxonomy/wording to declare assembly classification expressions
 (independend form other dimensions). At Runtime, the clearances of EACH taxonomic dimension needs to match before an assembly becomes approved.
 </summary>
</member>
<member name="M:ComponentDiscovery.ClassificationBasedAssemblyIndexer.AddTaxonomicDimension(System.String,System.String[])">
 <summary>
 Declares a new dimension to scope the set of available assemblies based on a taxonomy/wording to declare assembly classification expressions
 (independend form other dimensions). At Runtime, the clearances of EACH taxonomic dimension needs to match before an assembly becomes approved.
 This is a overloaded convenience method which adds a new dimension based on 
 a 'AttributeBasedAssemblyClassificationDetectionStrategy' (which reads the clearances for any assembly out of 
 "AssemblyClassificationAttributes" within the AssemblyInfo) in combination with
 a 'DemandCentricClassificationApprovalStrategy'
 </summary>
</member>
<member name="M:ComponentDiscovery.ClassificationBasedAssemblyIndexer.AddTaxonomicDimension(System.String,System.Func{System.String,System.Collections.Generic.List{System.String},System.Boolean},ComponentDiscovery.ClassificationApproval.IClassificationApprovalStrategy,System.String[])">
 <summary>
 Declares a new dimension to scope the set of available assemblies based on a taxonomy/wording to declare assembly classification expressions
 (independend form other dimensions). At Runtime, the clearances of EACH taxonomic dimension needs to match before an assembly becomes approved.
 This is a overloaded convenience method which adds a new dimension based on
 a 'DelegateBasedClassificationStrategy' in combination with
 a 'DemandCentricClassificationApprovalStrategy'
 </summary>
 <param name="assemblyClassificationEvaluationMethod"> this is how a assembly will be classified. You can specify a 
 method to run your own code evaluating classifications for a given assembly file name into a list of string)</param>
 <param name="classificationApprovalStrategy">this is how a assembly will be approved 
 (opposing the assembly's classifications against the enabled clearances).</param>
</member>
<member name="M:ComponentDiscovery.ClassificationBasedAssemblyIndexer.AddTaxonomicDimension(System.String,ComponentDiscovery.ClassificationDetection.IAssemblyClassificationDetectionStrategy,ComponentDiscovery.ClassificationApproval.IClassificationApprovalStrategy,System.String[])">
 <summary>
 Declares a new dimension to scope the set of available assemblies based on a taxonomy/wording to declare assembly classification expressions
 (independend form other dimensions). At Runtime, the clearances of EACH taxonomic dimension needs to match before an assembly becomes approved.
 </summary>
 <param name="taxonomicDimensionName"></param>
 <param name="classificationStrategy">this is how a assembly will be classified. in default you can choose between 
 the 'DelegateBasedClassificationStrategy' (which improves you run your own code returning a string() of classifications) OR 
 the 'AttributeBasedAssemblyClassificationStrategy' (which reads the clearances for any assembly out of 
 "AssemblyClassificationAttributes" within the AssemblyInfo)</param>
 <param name="defaultClearances">enable this clearances by default</param>
 <param name="classificationApprovalStrategy">this is how a assembly will be approved (opposing the assembly's classifications 
 against the enabled clearances).</param>
 <remarks>
   Only assemblies matching all clearances of dimensions will be approved.
   So adding dimensions will tend to narrowing down the set of approvable assemblies.
 </remarks>
</member>
<member name="M:ComponentDiscovery.ClassificationBasedAssemblyIndexer.AddClearances(System.String,System.String[])">
 <summary>
  Adds clearances to the internal clearance collection which will broaden the set of approvable assemblies.
  Note: if you plan to call this method multiple times (may be to setup multiple dimensions) then you
  should use the 'ImportClearances'-Method instead to prevent performance-issues!
 </summary>
 <remarks> Adding clearances could implicitely approve additional assemblies. </remarks>
</member>
<member name="M:ComponentDiscovery.ClassificationBasedAssemblyIndexer.AddClearancesFromAssembly(System.Reflection.Assembly)">
 <summary>
   Fetches the classification expressions from an assembly and adds them as clearance expressions.
 </summary>
 <remarks> 
   Adding clearances could implicitely approve additional assemblies.
   THIS METHOD DOES NOT APPROVE THE INCOMING ASSEMBLY. IF YOU WANT TO DO THIS YOU MUST USE <seealso cref="M:ComponentDiscovery.ClassificationBasedAssemblyIndexer.AddAssemblyAndImportClearances(System.Reflection.Assembly)"/>!
 </remarks>
 <seealso cref="M:ComponentDiscovery.ClassificationBasedAssemblyIndexer.AddAssemblyAndImportClearances(System.Reflection.Assembly)"/>
</member>
<member name="M:ComponentDiscovery.ClassificationBasedAssemblyIndexer.ReapproveDismissedAssemblies">
 <summary>
 NOTE: this will only reapprove when the internal dirty-marker is set!
 To enforce a reapproval use the overload and set the 'force' parameter.
 </summary>
</member>
<member name="M:ComponentDiscovery.ClassificationBasedAssemblyIndexer.ReapproveDismissedAssemblies(System.Boolean)">
 <summary>
 NOTE: this will only reapprove when the internal dirty-marker is set OR
 the 'force' parameter is set.
 </summary>
 <param name="force"></param>
</member>
<member name="M:ComponentDiscovery.ClassificationBasedAssemblyIndexer.ExecuteWithAggregatedReapprove(System.Action)">
 <summary>
 Invoke the given delegate without automatically calling 'ReapproveDismissedAssemblies()' for each clearance added.
 After the given delegate has been invoked, the 'ReapproveDismissedAssemblies()'
 will be called exactly once internally!
 The return value is true, if one or more clearances were added during the invoke.
 </summary>
</member>
<member name="P:ComponentDiscovery.ClassificationBasedAssemblyIndexer.AutoReapproveSuspendedForCurrentThread">
 <summary>
 REACTIVATING THE AUTO-APPROVAL WILL IMPLICITELY
 TRIGGER REAPPROVAL IF THE DIRTY-MARKER IS SET
 </summary>
</member>
<member name="M:ComponentDiscovery.ClassificationBasedAssemblyIndexer.OnReapproveDismissedAssembliesRequired">
 <summary>
  directly calls 'ReapproveDismissedAssemblies()' OR
  (if the auto reapproval is currently suspended) sets the dirty-marker,
  which indicates, that it needs to be called later...
 </summary>
</member>
<member name="M:ComponentDiscovery.ClassificationBasedAssemblyIndexer.AddAssemblyAndImportClearances(System.Reflection.Assembly)">
 <summary>
   Fetches the classification expressions from an assembly and adds them as clearance expressions.
 </summary>
 <remarks> 
   Importing clearances will implicitely approve the incoming assembly PLUS other assemblies that match the newly created clearance situation.
 </remarks>
</member>
<member name="M:ComponentDiscovery.ClassificationBasedAssemblyIndexer.VerifyAssemblyWithinOneDimension(System.String,System.String)">
 <summary>
   This will just check, if all assembly's classifications match the current clearance situation.
   This will NOT approve the assembly! (It won't be added to the index).
 </summary>
 <param name="assemblyFullFilename"> The assembly to verify. </param>
 <returns> True, if it's a match. </returns>
</member>
<member name="M:ComponentDiscovery.ClassificationBasedAssemblyIndexer.VerifyAssembly(System.String,System.Boolean)">
 <summary>
   This will just check, if all assembly's classifications match the current clearances situation.
   This is done for all dimensions - all dimensions have to match.
   This will NOT approve the assembly! (It won't be added to the index).
 </summary>
 <param name="assemblyFullFilename"> The assembly to verify. </param>
 <returns> True, if it's a match. </returns>
</member>
<member name="M:ComponentDiscovery.ClassificationBasedAssemblyIndexer.SummarizeMatchingResults(System.Collections.Generic.Dictionary{System.String,System.Boolean})">
 <summary>
   This can be hoocked to manipulate and break the strict conjunction (AND relation) of the scopes by implementing a custom predicate logic
 </summary>
</member>
<member name="M:ComponentDiscovery.ClassificationBasedAssemblyIndexer.ImportClearances(System.String[])">
 <summary>
   Adds clearances to the internal clearance collection which will broaden the set of approvable assemblies.
 </summary>
 <param name="qualifiedClearanceExpressions">a string-array where each element has a syntax like "DimensionName:ClearanceExpression".</param>
 <remarks> Importing clearances could implicitely approve additional assemblies. </remarks>
</member>
<member name="M:ComponentDiscovery.ClassificationBasedAssemblyIndexer.ImportClearances(System.Collections.Generic.Dictionary{System.String,System.String[]})">
 <summary>
   Adds clearances to the internal clearance collection which will broaden the set of approvable assemblies.
 </summary>
 <param name="clearancesSortedByDimension">a dictionary, where the KEY is the "DimensionName" and the VALUE is a string-array where each element is a ClearanceExpression (without a DimensionName)</param>
 <remarks> Importing clearances could implicitely approve additional assemblies. </remarks>
</member>
<member name="M:ComponentDiscovery.ClassificationApproval.ClassificationApprovalStrategyBase.#ctor(System.Boolean,System.Boolean)">
 <summary>
 </summary>
 <param name="resultIfNoClassifications">waht should be done with unclassified targets? (default=False)</param>
 <param name="enableRecursionForArborescentClassifications">Activate a logic which is similar to Namespaces - 
 if we have a target with classification "Foo.Bar.Car"
 then it will also pass the approval for a clearance "Foo.Bar" or "Foo", but not for a clearance like "Foo.Bar.Bike" </param>
</member>
<member name="T:ComponentDiscovery.ClassificationApproval.DemandCentricClassificationApprovalStrategy">
 <summary>
 A 'ClassificationApprovalStrategy' opposes classifications with clearances and returns true if conformity is given.
 This one does a 'demand based' evaluation, which requires at least one clearance for EACH classification to reach conformity!
 </summary>
</member>
<member name="M:ComponentDiscovery.ClassificationApproval.DemandCentricClassificationApprovalStrategy.#ctor(System.Boolean,System.Boolean)">
 <summary>
 </summary>
 <param name="resultIfNoClassifications">what should be done with unclassified targets? (default=False)</param>
 <param name="enableRecursionForArborescentClassifications">
 activate a logic which is similar to 'namespaces':  
 if we have a classification "Foo.Bar.XYZ" then it will also pass the approval
 for a clearance like "Foo.Bar" or "Foo", but not for a clearance like "Foo.Bar.ABC"
 </param>
</member>
<member name="M:ComponentDiscovery.ClassificationApproval.DemandCentricClassificationApprovalStrategy.VerifyTarget(System.String[],System.String[],System.String)">
 <summary>
 Opposes classifications with clearances and returns true if conformity is given.
 </summary>
</member>
<member name="T:ComponentDiscovery.ClassificationApproval.ExpressionCentricClassificationApprovalStrategy">
 <summary>
 A 'ClassificationApprovalStrategy' opposes classifications with clearances and returns true if conformity is given.
 This one does a 'expression based' evaluation, which requires conformity with each clearance and supports extended clearance 
 expressions like AND-Reations('Foo+Bar') or NOT-Operators('!For').
 </summary>
</member>
<member name="M:ComponentDiscovery.ClassificationApproval.ExpressionCentricClassificationApprovalStrategy.#ctor(System.Boolean,System.Boolean)">
 <summary>
 </summary>
 <param name="resultIfNoClassifications">what should be done with unclassified targets? (default=False)</param>
 <param name="enableRecursionForArborescentClassifications">
 activate a logic which is similar to 'namespaces':  
 if we have a classification "Foo.Bar.XYZ" then it will also pass the approval
 for a clearance like "Foo.Bar" or "Foo", but not for a clearance like "Foo.Bar.ABC"
 </param>
</member>
<member name="M:ComponentDiscovery.ClassificationApproval.ExpressionCentricClassificationApprovalStrategy.VerifyTarget(System.String[],System.String[],System.String)">
 <summary>
 Opposes classifications with clearances and returns true if conformity is given.
 </summary>
</member>
<member name="T:ComponentDiscovery.ClassificationApproval.IClassificationApprovalStrategy">
 <summary>
 A 'ClassificationApprovalStrategy' opposes classifications with clearances and returns true if conformity is given.
 </summary>
</member>
<member name="M:ComponentDiscovery.ClassificationApproval.IClassificationApprovalStrategy.VerifyTarget(System.String[],System.String[],System.String)">
 <summary>
   Opposes classifications with clearances and returns true if conformity is given.
 </summary>
</member>
<member name="T:ComponentDiscovery.ClassificationDetection.ManifestBasedAssemblyClassificationDetectionStrategy">
 <summary>
 Reads Classifications from a Manifest-File named right to the assembly file but with file-extension '.cl'.
 The Format must be JSON in the form: {
   "componentDiscovery": {
     "dimensionNameA": "SingleExpression",
     "dimensionNameB : ["OneExpression", "AnotherExpression"]
   } 
 }
 </summary>
</member>
<member name="M:ComponentDiscovery.ClassificationDetection.DelegateBasedAssemblyClassificationDetectionStrategy.#ctor(System.Func{System.String,System.Collections.Generic.List{System.String},System.Boolean})">
 <summary></summary>
 <param name="assemblyAnalyzerMethod">this is how a assembly will be classified. You can specify a method to run your 
 own code defining the string based classifications for a given assembly file name)</param>
</member>
<member name="M:ComponentDiscovery.IgnoreNamespaceClassificationsAttribute.#ctor(System.String)">
 <param name="taxonomicDimensionName"></param>
</member>
<member name="M:ComponentDiscovery.NamespaceClassificationAttribute.#ctor(System.String,System.String,System.String)">
 <param name="namespaceAndOrTypenameMask">a include-mask for namespace and/or typename (can be used with wildcard '*')</param>
 <param name="taxonomicDimensionName"></param>
 <param name="classificationExpression"></param>
</member>
<member name="M:ComponentDiscovery.TypeClassificationAttribute.#ctor(System.String,System.String)">
 <param name="taxonomicDimensionName"></param>
 <param name="classificationExpression"></param>
</member>
<member name="M:ComponentDiscovery.ProviderRepository`1.DumpFullState">
 <summary>
 Generates a Report for Diagnostics and Troubleshooting
 </summary>
</member>
<member name="M:ComponentDiscovery.ProviderRepository`1.Dispose">
 <summary>
 Dispose the current object instance and suppress the finalizer
 </summary>
</member>
<member name="P:ComponentDiscovery.AssemblyResolving.PrimaryApplicationRootDirectory">
 <summary>
 The primary fixpoint when resolving relative paths.
 Note: when running windows applications the 'PrimaryApplicationAssemblyDirectory' and the 'PrimaryApplicationRootDirectory' are equal - 
 BUT NOT UNDER ASP.NET!!!
 </summary>
</member>
<member name="P:ComponentDiscovery.AssemblyResolving.PrimaryApplicationAssemblyDirectory">
 <summary>
 The primary location of application binaries.
 Note: when running windows applications the 'PrimaryApplicationAssemblyDirectory' and the 'PrimaryApplicationRootDirectory' are equal - 
 BUT NOT UNDER ASP.NET!!!
 </summary>
</member>
<member name="M:ComponentDiscovery.AssemblyResolving.ResolveRelativePath(System.String)">
 <summary>
 returns a rooted full path from the given 'fullOrRelativePath' which will be evaluated using the 'PrimaryApplicationDirectory' as fixpoint
 </summary>
 <param name="fullOrRelativePath"></param>
 <returns></returns>
</member>
<member name="P:ComponentDiscovery.AssemblyResolving.ResolvePaths">
 <summary>
 Please dont use this property to build your own resolver! If the AssemblyResolving is initialized,
 you can easy use .NET (Fusion) to load your assembly without knowing its location: Assembly.Load("YourAssemblyName") 'without file extension!
 The only task is, to make sure that 'AssemblyResolving.Initialize()' has been called at least once!
 </summary>
</member>
<member name="E:ComponentDiscovery.ClassificationBasedTypeIndexer.TaxonomicDimension.ClearancesAdded">
 <summary>
   Occurs when clearance expressions have actually been added to the ClearanceLabels collection.
 </summary>
 <param name="addedClearanceExpressions"> An array of the effectively added labels. </param>
</member>
<member name="M:ComponentDiscovery.ClassificationBasedTypeIndexer.TaxonomicDimension.GetClassificationsWithRuntimeCaching(System.Type)">
 <summary>
 </summary>
 <param name="t"></param>
 <returns>CAN BE NOTHING !</returns>
</member>
<member name="M:ComponentDiscovery.ExtensionsForITypeIndexer.SubscribeForApplicableTypeFound``1(ComponentDiscovery.ITypeIndexer,System.Boolean,System.Action{System.Type})">
 <summary>
   Subscribe Types on the receiver delegate. WARNING: the delegate needs to be thread-safe!!!
 </summary>
</member>
<member name="M:ComponentDiscovery.ITypeIndexer.SubscribeForApplicableTypeFound(System.Type,System.Boolean,System.Action{System.Type})">
 <summary>
   Adds a subscription for a selector (type).
   If the selector is an interface, then we're indexing applicable implementations.
   If the selector is a class, then we're indexing applicable specializations.
   If the selector is an attribute, then we're indexing applicable types flagged with that.
   In addition, we can restrict the subscription to only these applicable types which, are 'parameterless instantiable'
   (means only non-abstract classes having a public default constrcutor or a public parameterless constructor).
   For every applicable type which matches to this constraint, the 'reciver' method will be invoked exactly once.
 </summary>
</member>
<member name="M:ComponentDiscovery.TypeIndexer.ApplicableTypesIndex.Dispose(System.Boolean)">
 <summary>
   Dispose the current object instance
 </summary>
</member>
<member name="M:ComponentDiscovery.TypeIndexer.ApplicableTypesIndex.Dispose">
 <summary>
   Dispose the current object instance and suppress the finalizer
 </summary>
</member>
<member name="M:ComponentDiscovery.TypeIndexer.RegisterCandidate(System.Type)">
 <summary>
   Explicitely adds a type to the index.
 </summary>
 <remarks>
   This is an exceptional use of the type indexer. Normally, types are found automatically within indexed assemblies.
   This method can be used to add types to the index that - for some reasons - shouldn't be discovered by seeking assemblies.
 </remarks>
</member>
<member name="M:ComponentDiscovery.TypeIndexer.DumpFullState">
 <summary>
 Generates a Report for Diagnostics and Troubleshooting
 </summary>
</member>
<member name="M:ComponentDiscovery.TypeIndexer.Dispose(System.Boolean)">
 <summary>
   Dispose the current object instance
 </summary>
</member>
<member name="M:ComponentDiscovery.TypeIndexer.Dispose">
 <summary>
   Dispose the current object instance and suppress the finalizer
 </summary>
</member>
<member name="T:Composition.InstanceDiscovery.CreatesDiscoverableInstanceAttribute">
 <summary>
 Declares, that this CONSTRUCTOR or STATIC METHOD shall be used as factory to
 create discoverable (short living) instances 'on-demand' when they are requested.
 This attribute must be used together with the 'SupportsInstanceDiscoveryAttribute' on the class.
 NOTE: if this attribute is used on targets with non-optional parameters, you'll need to declare
 an 'InjectAttribute' or 'TryInjectAttribute' on each of these parameters to enable DI!
 </summary>
</member>
<member name="M:Composition.InstanceDiscovery.CreatesDiscoverableInstanceAttribute.#ctor(System.Type)">
 <summary>
 Declares, that this CONSTRUCTOR or STATIC METHOD shall be used as factory to
 create discoverable (short living) instances 'on-demand' when they are requested.
 This attribute must be used together with the 'SupportsInstanceDiscoveryAttribute' on the class.
 NOTE: if this attribute is used on targets with non-optional parameters, you'll need to declare
 an 'InjectAttribute' or 'TryInjectAttribute' on each of these parameters to enable DI!
 </summary>
 <param name="discoverableAsType">
 needs to be specified only if the type under which this instance should be
 discoverable is not equal to to the return type (may be a base-class or interface).
 </param>
</member>
<member name="T:Composition.InstanceDiscovery.InjectAttribute">
 <summary>
 Declares the demand to get an discovered instance injected.
 If the instance discovery fails, an Exception will be thrown!
 This attribute must be used together with the 'SupportsInstanceDiscoveryAttribute' on the class.
 </summary>
</member>
<member name="M:Composition.InstanceDiscovery.InjectAttribute.#ctor(System.Type)">
 <summary>
 Declares the demand to get an discovered instance injected.
 If the instance discovery fails, an Exception will be thrown!
 This attribute must be used together with the 'SupportsInstanceDiscoveryAttribute' on the class.
 </summary>
 <param name="typeToDiscover">an more specific type which shuld be requested from the instance discovery framework (and which is assignable to the declative type on the target)</param>
</member>
<member name="T:Composition.InstanceDiscovery.PriorizeInstanceDiscoveryAgainstAttribute">
 <summary>
 Declares a rule which affects the priorization of all discoverable instances, which are registered using a
 'CreatesDiscoverableInstanceAttribute' or 'ProvidesDiscoverableInstanceAttribute' on this class,
 against discoverable instances which are provided from the specified foreign provider/origin type.
 </summary>
</member>
<member name="M:Composition.InstanceDiscovery.PriorizeInstanceDiscoveryAgainstAttribute.#ctor(System.Type,System.Boolean)">
 <summary>
 Declares a rule which affects the priorization of all discoverable instances, which are registered using a
 'CreatesDiscoverableInstanceAttribute' or 'ProvidesDiscoverableInstanceAttribute' on this class,
 against discoverable instances which are provided from the specified foreign provider/origin type.
 </summary>
 <param name="foreignOriginType">
 Provider/origin type against which the current class shoud be priorized
 </param>
 <param name="currentIsPreferred">
 Specifies, the current class is the preferred one ('false' will prefer the given 'foreignOriginType')
 </param>
</member>
<member name="P:Composition.InstanceDiscovery.PriorizeInstanceDiscoveryAgainstAttribute.ForeignOriginType">
 <summary>
 Provider/origin type against which the current class shoud be priorized
 </summary>
</member>
<member name="P:Composition.InstanceDiscovery.PriorizeInstanceDiscoveryAgainstAttribute.CurrentIsPreferred">
 <summary>
 Specifies, the current class is the preferred one ('false' will prefer the given 'foreignOriginType')
 </summary>
</member>
<member name="T:Composition.InstanceDiscovery.PriorizeInstanceDiscoveryAttribute">
 <summary>
 Declares a rule which affects the priorization of all discoverable instances, which are registered using a
 'CreatesDiscoverableInstanceAttribute' or 'ProvidesDiscoverableInstanceAttribute' on this class,
 against discoverable instances which are provided by any foreign provider/origin type.
 </summary>
</member>
<member name="M:Composition.InstanceDiscovery.PriorizeInstanceDiscoveryAttribute.#ctor(System.Boolean)">
 <summary>
 Declares a rule which affects the priorization of all discoverable instances, which are registered using a
 'CreatesDiscoverableInstanceAttribute' or 'ProvidesDiscoverableInstanceAttribute' on this class,
 against discoverable instances which are provided by any foreign provider/origin type.
 </summary>
 <param name="currentIsPreferred">
 Specifies, the current class is the preferred one ('false' will prefer any other foreign provider/origin)
 </param>
</member>
<member name="P:Composition.InstanceDiscovery.PriorizeInstanceDiscoveryAttribute.CurrentIsPreferred">
 <summary>
 Specifies, the current class is the preferred one ('false' will prefer any other foreign provider/origin)
 </summary>
</member>
<member name="T:Composition.InstanceDiscovery.ProvidesDiscoverableInstanceAttribute">
 <summary>
 Declares, that this STATIC PARAMETERLESS METHOD or STATIC PARAMETERLESS PROPERTY provides a
 managed instance (usually a SINGLETON) to be discovered.
 This attribute must be used together with the 'SupportsInstanceDiscoveryAttribute' on the class.
 NOTE: if this attribute is used on targets with non-optional parameters, you'll need to declare
 an 'InjectAttribute' or 'TryInjectAttribute' on each of these parameters to enable DI!
 </summary>
</member>
<member name="M:Composition.InstanceDiscovery.ProvidesDiscoverableInstanceAttribute.#ctor(System.Type,System.Boolean)">
 <summary>
 Declares, that this STATIC PARAMETERLESS METHOD or STATIC PARAMETERLESS PROPERTY provides a
 managed instance (usually a SINGLETON) to be discovered.
 This attribute must be used together with the 'SupportsInstanceDiscoveryAttribute' on the class.
 NOTE: if this attribute is used on targets with non-optional parameters, you'll need to declare
 an 'InjectAttribute' or 'TryInjectAttribute' on each of these parameters to enable DI!
 </summary>
 <param name="discoverableAsType">
 needs to be specified only if the type under which this instance should be
 discoverable is not equal to to the return type (may be a base-class or interface).
 </param>
 <param name="providesNullDiscoverable">
 if true, then the provider will use returned null values as valid discovery result and pass it to the consumers 
 (this option is useful, when the instance is optional within the system).
 Otherwise the provider will just respond that it cannot provide instances of this type, so that the framework 
 will skip the provider and continue asking other providers (this option is useful, when the instance is just not jet available
 or there are multiple providers for one type).
 </param>
</member>
<member name="T:Composition.InstanceDiscovery.SupportsInstanceDiscoveryAttribute">
 <summary>
 Declares, that the current class consumes discoverable instances, provides discoverable instances or can be used to create some.
 This attribute just flags the current class to be inspected when the instance discovery framework
 is searching for Methods, Properties or Constructors with a 'ProvidesDiscoverableInstanceAttribute', 
 'CreatesDiscoverableInstanceAttribute' or 'InjectAttribute'.
 These must be used together with this attribute on the class.
 </summary>
</member>
<member name="M:Composition.InstanceDiscovery.SupportsInstanceDiscoveryAttribute.#ctor">
 <summary>
 Declares, that the current class consumes discoverable instances, provides discoverable instances or can be used to create some.
 This attribute just flags the current class to be inspected when the instance discovery framework
 is searching for Methods, Properties or Constructors with a 'ProvidesDiscoverableInstanceAttribute', 
 'CreatesDiscoverableInstanceAttribute' or 'InjectAttribute'.
 These must be used together with this attribute on the class.
 </summary>
</member>
<member name="T:Composition.InstanceDiscovery.TryInjectAttribute">
 <summary>
 Declares the demand to get an discovered instance injected if possible.
 If the instance discovery fails, the behaviour for PARAMETER-INJECTION will be that
 a null-reference will be passed into required parameters and optional parameters will not be provided.
 Any MEMBER-INJECTION will simply be skipped.
 This attribute must be used together with the 'SupportsInstanceDiscoveryAttribute' on the class.
 </summary>
</member>
<member name="M:Composition.InstanceDiscovery.TryInjectAttribute.#ctor(System.Type)">
 <summary>
 Declares the demand to get an discovered instance injected if possible.
 If the instance discovery fails, the behaviour for PARAMETER-INJECTION will be that
 a null-reference will be passed into required parameters and optional parameters will not be provided.
 Any MEMBER-INJECTION will simply be skipped.
 This attribute must be used together with the 'SupportsInstanceDiscoveryAttribute' on the class.
 </summary>
 <param name="typeToDiscover">an more specific type which shuld be requested from the instance discovery framework (and which is assignable to the declative type on the target)</param>
</member>
<member name="P:Composition.InstanceDiscovery.AttributeBasedDiscoverableInstanceProvider.DedicatedDiscoverableTypes">
 <summary>
 If the provider offers a fixed amount of known types, then it can declare them over this
 property to avoid being asked by the framework for instances of any other type.
 An empty array as return value has the semantic, that no instances of any type is provided.
 An return value of null has the semantic, that the provider has a dynamic amount of known types,
 which forces the framework to ask it each time. 
 </summary>
</member>
<member name="P:Composition.InstanceDiscovery.AttributeBasedDiscoverableInstanceProvider.RepresentingOriginType">
 <summary>
 This used to address an instance-source when relating multiple sources in order to specify
 overriding rules like 'prefer MyCustomizedServiceProvider instead of MyCommonServiceProvider'.
 In most cases this is equal to the concrete implmentation of the 'IDiscoverableInstanceProvider'
 interface except in constellations, where providers are just wrapping another source -> then its
 possible to disclose the 'real' source here (to be addressed by overriding rules)
 </summary>
</member>
<member name="M:Composition.InstanceDiscovery.AttributeBasedDiscoverableInstanceProvider.DeclarePriorizationRules(System.Action{System.Type,System.Boolean})">
 <summary>
 Each provider which is added to the InstanceAccessContext be be asked to 
 declare priorization rules (in addition to the possibility to declare priorization
 rules in a centralized way on directly at the InstanceAccessContext). If this
 method is invoked, then the provider can use the callback to create one or more
 rules by passign a foreign/related origin type and a value of 'true' 
 when the current provider shloud be preferred against this type or 'false' when the foreign
 one should be preferred.
 </summary>
</member>
<member name="M:Composition.InstanceDiscovery.AttributeBasedDiscoverableInstanceProvider.TryGetInstance(Composition.InstanceDiscovery.InstanceDiscoveryContext,System.Type,System.Object@,Composition.InstanceDiscovery.LifetimeResponsibility@)">
 <summary>
 </summary>
 <param name="requestingContext">will be used as source for other instances, if injection is enabled</param>
 <param name="requestedType"></param>
 <param name="instance"></param>
 <param name="lifetimeResponsibility">
 informs, which party (the provider or the consumer) has the responsibility
 to manage the lifecycle of the returned instances including their disposal.
 </param>
 <returns></returns>
</member>
<member name="P:Composition.InstanceDiscovery.IDiscoverableInstanceProvider.RepresentingOriginType">
 <summary>
 This used to address an instance-source when relating multiple sources in order to specify
 overriding rules like 'prefer MyCustomizedServiceProvider instead of MyCommonServiceProvider'.
 In most cases this is equal to the concrete implmentation of the 'IDiscoverableInstanceProvider'
 interface except in constellations, where providers are just wrapping another source -> then its
 possible to disclose the 'real' source here (to be addressed by overriding rules)
 </summary>
</member>
<member name="M:Composition.InstanceDiscovery.IDiscoverableInstanceProvider.DeclarePriorizationRules(System.Action{System.Type,System.Boolean})">
 <summary>
 Each provider which is added to the InstanceAccessContext be be asked to 
 declare priorization rules (in addition to the possibility to declare priorization
 rules in a centralized way on directly at the InstanceAccessContext). If this
 method is invoked, then the provider can use the callback to create one or more
 rules by passign a foreign/related origin type and a value of 'true' 
 when the current provider shloud be preferred against this type or 'false' when the foreign
 one should be preferred.
 </summary>
</member>
<member name="P:Composition.InstanceDiscovery.IDiscoverableInstanceProvider.DedicatedDiscoverableTypes">
 <summary>
 If the provider offers a fixed amount of known types, then it can declare them over this
 property to avoid being asked by the framework for instances of any other type.
 An empty array as return value has the semantic, that no instances of any type is provided.
 An return value of null has the semantic, that the provider has a dynamic amount of known types,
 which forces the framework to ask it each time. 
 </summary>
</member>
<member name="M:Composition.InstanceDiscovery.IDiscoverableInstanceProvider.TryGetInstance(Composition.InstanceDiscovery.InstanceDiscoveryContext,System.Type,System.Object@,Composition.InstanceDiscovery.LifetimeResponsibility@)">
 <summary>
 
 </summary>
 <param name="requestingContext"></param>
 <param name="requestedType"></param>
 <param name="instance"></param>
 <param name="lifetimeResponsibility">
 informs, which party (the provider or the consumer) has the responsibility
 to manage the lifecycle of the returned instances including their disposal.
 </param>
 <returns></returns>
</member>
<member name="F:Composition.InstanceDiscovery.InjectionDemand.SuccessOrThrow">
 <summary>
 If the instance discovery fails, then the framework will throw an Exception!
 </summary>
</member>
<member name="F:Composition.InstanceDiscovery.InjectionDemand.SuccessOrNull">
 <summary>
 If the instance discovery fails, then a null-refernce will be passed!
 </summary>
</member>
<member name="F:Composition.InstanceDiscovery.InjectionDemand.SuccessOrSkip">
 <summary>
 If the instance discovery fails, then the framework shlud not provide anything!
 (only possible when the injection-target is a MEMBER or a OPTIONAL-PARAMETER)
 </summary>
</member>
<member name="F:Composition.InstanceDiscovery.InjectionDemand.SkipAlways">
 <summary>
 used as default for OPTIONAL-PARAMETERs which dont have an injection attribute
 </summary>
</member>
<member name="T:Composition.InstanceDiscovery.InstanceDiscoveryContext">
 <summary>
 provides access to discoverable instances
 </summary>
</member>
<member name="M:Composition.InstanceDiscovery.InstanceDiscoveryContext.EnableDelayedDisposal">
 <summary>
 starts tracking of sub-threads in order to wait for them
 to finish during the disposal of this instance.
 Calling the 'Dispose' method will NOT wait and immediately end,
 but the disposal itself will be delayed in background 
 (so this works fine with a 'using'-block)!  
 </summary>
</member>
<member name="M:Composition.InstanceDiscovery.InstanceDiscoveryContext.Dispose">
 <summary>
 disposes all 'self-managed' instances for which the lifetime-handling has been delegated to this context
 </summary>
</member>
<member name="M:Composition.InstanceDiscovery.InstanceDiscoveryContext.DumpFullState">
 <summary>
 Generates a Report for Diagnostics and Troubleshooting
 </summary>
</member>
<member name="T:Composition.InstanceDiscovery.LifetimeResponsibility">
 <summary>
 Defines which party (the provider or the consumer) has the responsibility to manage the lifecycle of an instance.
 </summary>
</member>
<member name="F:Composition.InstanceDiscovery.LifetimeResponsibility.Managed">
 <summary>
 Defines, that the lifetime of an instance is managed internally by the provider.
 This means, that the consumer should treat the exposed instance like a SINGLETON
 and MUST NOT DISPOSE it!
 </summary>
</member>
<member name="F:Composition.InstanceDiscovery.LifetimeResponsibility.Delegated">
 <summary>
 Defines, that any lifetime handling of a exposed instance is delegated to the consumer.
 This means, that the consumer should treat the exposed instance like it CAME FROM A FACTORY
 which includes a consumer-side responsibility to TAKE CARE OF CORRECT DISPOSAL.
 </summary>
</member>
</members>
</doc>
